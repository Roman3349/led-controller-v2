// *********************************************************************
//   Custom DPA Handler code example - Standard Sensors - Thermometer  *
// *********************************************************************
// Copyright (c) IQRF Tech s.r.o.

// Default IQRF include (modify the path according to your setup)
#include "include/IQRF.h"

// Default DPA header (modify the path according to your setup)
#include "include/DPA.h"
// Default Custom DPA Handler header (modify the path according to your setup)
#include "include/DPAcustomHandler.h"
// IQRF standards header (modify the path according to your setup)
#include "include/IQRFstandard.h"
#include "include/IQRF_HWPID.h"

// Custom bonding button. Change to the pin and an active level of your choice.
#define	IsButton  ( !PORTA.0 )

// TX byte to UART
void TxUART( uns8 data );
// RX byte from UART; W = read byte, Carry = byte was read
bit RxUART();

// UART baud rate
#define UART_BAUD 115200

// Number of UART received bytes
uns8 RxDataLengthUART;

// Length of RX and TX buffers, must be power of 2
#define UART_BUFFER_LENGTH     16

#if 0 != ( UART_BUFFER_LENGTH & ( UART_BUFFER_LENGTH - 1 ) )
#error UART_BUFFER_LENGTH is not power of 2
#endif

// Rx
// Circular RX UART buffer pointers
uns8 RxBufferPointerStartUART;
uns8 RxBufferPointerEndUART;
uns8 RxBufferUART[UART_BUFFER_LENGTH] /*@ PeripheralRam[0]*/;

// TX
// Circular TX UART buffer pointers
uns8 TxBufferPointerStartUART;
uns8 TxBufferPointerEndUART;
uns8 TxBufferUART[UART_BUFFER_LENGTH] /*@ PeripheralRam[UART_BUFFER_LENGTH]*/;

// Division macro with rounding
#define DIV(Dividend,Divisor) (((Dividend+((Divisor)>>1))/(Divisor)))
// PIC baud register computation
#define UART_SPBRG_VALUE( Baud )  ( DIV( F_OSC, ( ( ( uns24 )4  ) * ( Baud ) ) ) - 1 )

// Calibration value address in the EEPROM
#define TEMP_CALIBRATION_ADDRESS  0

// Initial calibration value is 0
#pragma cdata[ __EESTART + TEMP_CALIBRATION_ADDRESS ] = 0, 0

// Calibrates temperature at param3, that was read by getTemperature()
void CalibrateParam3();

// Must be the 1st defined function in the source code in order to be placed at the correct FLASH location!
//############################################################################################
bit CustomDpaHandler()
//############################################################################################
{
  // This forces CC5X to wisely use MOVLB instructions (doc says:  The 'default' bank is used by the compiler for loops and labels when the algorithm gives up finding the optimal choice)
#pragma updateBank default = UserBank_01

  // Handler presence mark
  clrwdt();

  // TXIE state before sleep
  static bit wasTXIE;

  // Sleeping parameters, valid when Time != 0
  static TPerOSSleep_Request PerOSSleep_Request;

  // Detect DPA event to handle
  switch ( GetDpaEvent() )
  {
    case DpaEvent_Interrupt:
      // Do an extra quick background interrupt work
      // ! The time spent handling this event is critical.If there is no interrupt to handle return immediately otherwise keep the code as fast as possible.
      // ! Make sure the event is the 1st case in the main switch statement at the handler routine.This ensures that the event is handled as the 1st one.
      // ! It is desirable that this event is handled with immediate return even if it is not used by the custom handler because the Interrupt event is raised on every MCU interrupt and the “empty” return handler ensures the shortest possible interrupt routine response time.
      // ! Only global variables or local ones marked by static keyword can be used to allow reentrancy.
      // ! Make sure race condition does not occur when accessing those variables at other places.
      // ! Make sure( inspect.lst file generated by C compiler ) compiler does not create any hidden temporary local variable( occurs when using division, multiplication or bit shifts ) at the event handler code.The name of such variable is usually Cnumbercnt.
      // ! Do not call any OS functions except setINDFx().
      // ! Do not use any OS variables especially for writing access.
      // ! All above rules apply also to any other function being called from the event handler code, although calling any function from Interrupt event is not recommended because of additional MCU stack usage.

      // -----------------------------------------------------------------------------------------
      // UART Receive
      //
      if ( RCIF )
      {
        // We ignore FERR
        FSR1L = RCREG;
        // Put the received byte in circular buffer
        if ( RxDataLengthUART < UART_BUFFER_LENGTH )
        {
          // One more byte received
          RxDataLengthUART++;
          // Prepare pointer
          FSR0 = RxBufferUART + RxBufferPointerEndUART;
          // Recalculate tail pointer
          // Optimization: Same as (UART_BUFFER_LENGTH is power of 2) : RxBufferPointerEndUART = ( RxBufferPointerEndUART + 1 ) % UART_BUFFER_LENGTH;
          RxBufferPointerEndUART++;
          RxBufferPointerEndUART &= ~UART_BUFFER_LENGTH;
          // Store byte
          setINDF0( FSR1L );
        }
      }

      // Overrun recovery (we do it after receiving UART byte in order to receive it as soon as possible)
      if ( OERR )
        CREN = 0;

      // Seems excess, but at the end it is shorted and faster than having this statement at else branch
      CREN = 1;

      // -----------------------------------------------------------------------------------------
      // UART Transmit
      //
      if ( TXIF && TXIE )
      {
        // Send byte from circular buffer to the UART
        FSR0 = TxBufferUART + TxBufferPointerStartUART;
        TxBufferPointerStartUART = ( TxBufferPointerStartUART + 1 ) % UART_BUFFER_LENGTH;
        // Buffer empty?
        if ( TxBufferPointerStartUART == TxBufferPointerEndUART )
          TXIE = FALSE;
        // TX the byte
        TXREG = *FSR0;
      }

      // Return value does not matter
      return Carry;
    case DpaEvent_BondingButton:
      // Called to allow a bonding button customization

      userReg1.0 = 0;
      if ( IsButton )
        userReg1.0 = 1;
      goto DpaHandleReturnTRUE;

    case DpaEvent_Init:
      // Do a one time initialization before main loop starts

      // Connected TR pins (e.g. TR72D)?
      moduleInfo();
      if ( !bufferINFO[5].7 )
      {
        // Set them as inputs
        TRISC.5 = 1;
        TRISA.5 = 1;
        TRISB.4 = 1;
      }

      // RX input
      TRISC.7 = 1;
      // TX output
      TRISC.6 = 0;

      // Set baud rate
      SPBRGL = UART_SPBRG_VALUE( UART_BAUD ) & 0xff;
      SPBRGH = UART_SPBRG_VALUE( UART_BAUD ) >> 8;
      // baud rate control setup: BRG16 = 1
      BAUDCON = 0b0000.1.000;

      // CSRC TX9 TXEN SYNC SENDB BRGH TRMT TX9D
      // TXEN = 1
      // BRGH = 1
      // async UART, high speed, 8 bit, TX enabled
      TXSTA = 0b0010.0100;

      // SPEN RX9 SREN CREN ADDEN FERR OERR RX9D
      // SPEN = 1
      // CREN = 1
      // Continuous receive, enable port, 8 bit
      RCSTA = 0b1001.0000;
      // Enable UART RX interrupt
      RCIE = TRUE;

      break;


    case DpaEvent_Idle:
      // Do a quick background work when RF packet is not received

      // Should go to sleep?
      if ( PerOSSleep_Request.Time != 0 )
      {
        // Copy sleep parameters to the DPA request
        _DpaMessage.PerOSSleep_Request.Time = PerOSSleep_Request.Time;
        _DpaMessage.PerOSSleep_Request.Control = PerOSSleep_Request.Control;
        // Switch off sleeping time=flag
        PerOSSleep_Request.Time = 0;
        // Finalize OS Sleep DPA Request
        _DpaDataLength = sizeof( _DpaMessage.PerOSSleep_Request );
        _PNUM = PNUM_OS;
        _PCMD = CMD_OS_SLEEP;
        // Perform local DPA Request to go to sleep
        DpaApiLocalRequest();
      }
      break;

      // -------------------------------------------------
    case DpaEvent_DpaRequest:
      // Called to interpret DPA request for peripherals
      // -------------------------------------------------
      // Peripheral enumeration
      if ( IsDpaEnumPeripheralsRequest() )
      {
        // We implement 1 standard peripheral
        _DpaMessage.EnumPeripheralsAnswer.UserPerNr = 1;
        FlagUserPer( _DpaMessage.EnumPeripheralsAnswer.UserPer, PNUM_STD_SENSORS );
        _DpaMessage.EnumPeripheralsAnswer.HWPID = 0x123F;
        _DpaMessage.EnumPeripheralsAnswer.HWPIDver = 0x0001;

DpaHandleReturnTRUE:
        return TRUE;
      }
      // -------------------------------------------------
      // Get information about peripheral
      else if ( IsDpaPeripheralInfoRequest() )
      {
        if ( _PNUM == PNUM_STD_SENSORS )
        {
          _DpaMessage.PeripheralInfoAnswer.PerT = PERIPHERAL_TYPE_STD_SENSORS;
          _DpaMessage.PeripheralInfoAnswer.PerTE = PERIPHERAL_TYPE_EXTENDED_READ;
          // Set standard version
          _DpaMessage.PeripheralInfoAnswer.Par1 = STD_SENSORS_VERSION;
          goto DpaHandleReturnTRUE;
        }

        break;
      }
      // -------------------------------------------------
      else
      {
        // Handle peripheral command

        // Supported peripheral number?
        if ( _PNUM == PNUM_STD_SENSORS )
        {
          // Supported commands?
          switch ( _PCMD )
          {
            // Invalid command
            default:
              // Return error
              W = ERROR_PCMD;
              goto _ERROR_W;

              // Sensor enumeration
            case PCMD_STD_ENUMERATE:
              if ( _DpaDataLength != 0 )
              {
_ERROR_DATA_LEN:
                W = ERROR_DATA_LEN;
                goto _ERROR_W;
              }

              _DpaDataLength |= 1; // = 1 (optimization as _DpaDataLength was 0 for sure)
              goto _Enumerate;

              // Supported commands. They are handled almost the same way
            case PCMD_STD_SENSORS_READ_VALUES:
            case PCMD_STD_SENSORS_READ_TYPES_AND_VALUES:
            {
              bit returnCalibration = FALSE;

              // No sensor bitmap specified? W = _DpaDataLength. Note: W is used to avoid MOVLB at next if
              W = _DpaDataLength;
              if ( W == 0 )	// Note: must not modify W
              {
                // Bitmap is 32 bits long = 4 (Note: using here save MOVLB)
                _DpaDataLength = W = sizeof( _DpaMessageIqrfStd.PerStdSensorRead_Request.Bitmap );
                // Simulate 1st sensor in the bitmap (states of the other unimplemented sensors do not care)
                _DpaMessage.Request.PData[0].0 = 1; // Note: must not modify W
              }

              // Invalid bitmap (data) length (W = _DpaDataLength)?
              switch ( W )
              {
                // Yes!
                default:
                  // Return error
                  goto _ERROR_DATA_LEN;

                  // No extra data written to sensor
                case ( (uns8)( sizeof( _DpaMessageIqrfStd.PerStdSensorRead_Request.Bitmap ) ) ):
                  break;

                  // Extra data written to sensor
                case ( (uns8)( sizeof( _DpaMessageIqrfStd.PerStdSensorRead_Request.Bitmap ) + 5 ) ):
                  // To the 1st i.e. temperature sensor?
                  if ( FSR1[offsetof( TPerStdSensorRead_Request, WrittenData ) + 0] != 0 )
                  {
                    // No, error
_ERROR_DATA:
                    W = ERROR_DATA;
_ERROR_W:
                    DpaApiReturnPeripheralError( W );
                  }

                  // Parse data content
                  switch ( FSR1[offsetof( TPerStdSensorRead_Request, WrittenData ) + 1] )
                  {
                    // Invalid 1st "header" byte
                    default:
                      goto _ERROR_DATA;

                      // Get calibration temperature
                    case STD_SENSOR_TYPE_TEMPERATURE_DATA_GET_1_POINT_CALIBRATION:
                      returnCalibration = TRUE;
                      break;

                      // Set calibration temperature
                    case STD_SENSOR_TYPE_TEMPERATURE_DATA_SET_1_POINT_CALIBRATION:
                      // Write calibration to the memory
                      bufferINFO[0] = FSR1[offsetof( TPerStdSensorRead_Request, WrittenData ) + 2];
                      bufferINFO[1] = FSR1[offsetof( TPerStdSensorRead_Request, WrittenData ) + 3];
                      eeWriteData( TEMP_CALIBRATION_ADDRESS, sizeof( uns16 ) );
                      break;
                  }
                  break;
              }

              // Get ready return data length for temperature data only (Note: optimization, 2 = 4/2 is used to save)
              _DpaDataLength = sizeof( uns16 );

              // Is my only sensor selected?
              if ( _DpaMessage.Request.PData[0].0 )
              {
                // Measure temperature?
                if ( !returnCalibration )
                {
                  // Error reading temperature? Note: param3 holds temperature value after calling getTemperature()
                  if ( getTemperature() == -128 )
                    // Return standard error value
                    STD_SENSOR_TYPE_TEMPERATURE_SET_ERROR( param3 );
                  else
                    CalibrateParam3();
                }
                else
                {
                  // No, return calibration
                  param3 = 0;
                  CalibrateParam3();
                }

                // Return the sensor type too?
                if ( _PCMD == PCMD_STD_SENSORS_READ_TYPES_AND_VALUES )
                {
                  // 3 bytes (1 byte with type, 2 bytes with temperature value) will be returned
                  _DpaDataLength++;
_Enumerate:
                  // 1st byte is sensor type
                  _DpaMessage.Response.PData[0] = STD_SENSOR_TYPE_TEMPERATURE;
                  // 3rd byte is higher byte of temperature value
                  _DpaMessage.Response.PData[2] = param3.high8;
                  // 2nd byte is lower byte of temperature value
                  W = param3.low8;
                }
                else
                {
                  // 2 bytes to return
                  // 1st byte is lower byte of temperature value
                  _DpaMessage.Response.PData[0] = param3.low8;
                  // 2nd byte is higher byte of temperature value
                  W = param3.high8;
                }

                // Store 2nd byte for both supported commands
                _DpaMessage.Response.PData[1] = W;
                // Handled!
                goto DpaHandleReturnTRUE;
              }
              else
              {
                // My sensor not selected, so no data returned
                _DpaDataLength = 0;
                goto DpaHandleReturnTRUE;
              }
            }
          }
        }

        break;
      }

      // -------------------------------------------------
    case DpaEvent_FrcValue:
      // Called to get FRC value

      // Check for correct FRC and FRC user data (signature byte and sensor index == 0)
      switch ( _PCMD )
      {
        case FRC_STD_SENSORS_1B:
        case FRC_STD_SENSORS_2B:
          // FSR1 for optimization purposes (avoid MOVLB) will be used to point to DataOutBeforeResponseFRC[0...]
          FSR1 = &DataOutBeforeResponseFRC[0];

          if ( *FSR1++ /*DataOutBeforeResponseFRC[0]*/ == PNUM_STD_SENSORS &&
               ( *FSR1 /*DataOutBeforeResponseFRC[1]*/ == 0x00 || *FSR1 /*DataOutBeforeResponseFRC[1]*/ == STD_SENSOR_TYPE_TEMPERATURE ) &&
               ( *++FSR1 /*DataOutBeforeResponseFRC[2]*/ & 0x1f ) == 0 )
          {
            // Return error code
            responseFRCvalue2B = FRC_STD_FRC_ERROR_VALUE;
            // Get temperature and adjust it for FRC
            // Temperature OK?
            if ( getTemperature() != -128 )
            {
              // Calibrate the temperatures
              CalibrateParam3();

              if ( _PCMD == FRC_STD_SENSORS_2B )
              {

                // Return sensor FRC value 2B
                responseFRCvalue2B = param3 ^ 0x8000;
              }
              else
              {
                // Return sensor FRC value 1B
                // Check for out of limits
                if ( (int16)param3 <= (int16)( 105.5 * 16 ) && (int16)param3 >= ( (int16)-20 * 16 ) )
                {
                  // Convert to the "F = ( T + 22 ) * 2 " from 1/16 resolution
                  param3 += 8 / 2 + (uns16)44 * 8; // Note: do rounding for /8
                  param3 /= 8;
                  responseFRCvalue = param3.low8;
                }
              }
            }

            // The sensor was measured by FRC, check if there is a sleep request
            FSR1++;
            if ( INDF1.0 ) // Note: same as DataOutBeforeResponseFRC[3].0
            {
              // Remember sleep parameters to go to sleep at the Idle event later
              PerOSSleep_Request.Time.low8 = FSR1[4 - 3]; // Note: same as DataOutBeforeResponseFRC[4]
              PerOSSleep_Request.Time.high8 = FSR1[5 - 3]; // Note: same as DataOutBeforeResponseFRC[5]
              PerOSSleep_Request.Control = FSR1[6 - 3]; // Note: same as DataOutBeforeResponseFRC[6]
            }
          }
          break;
      }
      break;

      // -------------------------------------------------
    case DpaEvent_FrcResponseTime:
      // Called to get FRC response time

      // In this example the FRC command is a fast one
      switch ( DataOutBeforeResponseFRC[0] )
      {
        case FRC_STD_SENSORS_1B:
        case FRC_STD_SENSORS_2B:
          responseFRCvalue = _FRC_RESPONSE_TIME_40_MS;
          break;
      }
      break;
    case DpaEvent_AfterSleep:
      // Called after woken up after sleep

      TXIE = wasTXIE;
      RCIE = TRUE;
      break;
    case DpaEvent_DisableInterrupts:
      // Called when device needs all hardware interrupts to be disabled (before Reset, Restart, LoadCode, Remove bond, and Run RFPGM)

      wasTXIE = TXIE;
      TXIE = FALSE;
      RCIE = FALSE;
      break;
  }

DpaHandleReturnFALSE:
  return FALSE;
}


//############################################################################################
// Note: make sure the parameter does not overlap another variable as the function is ready to be called from (timer) interrupt too
static uns8 _data;
void TxUART( uns8 data @ _data )
//############################################################################################
{
  // Wait for a space in the buffer
  while ( TXIE && TxBufferPointerStartUART == TxBufferPointerEndUART );

  // Disable TX interrupt
  TXIE = FALSE;
  // Compute pointer
  FSR0 = TxBufferUART + TxBufferPointerEndUART;
  // Optimization: TxBufferPointerEndUART = ( TxBufferPointerEndUART + 1 ) % UART_BUFFER_LENGTH;
  TxBufferPointerEndUART++;
  TxBufferPointerEndUART &= ~UART_BUFFER_LENGTH;
  // Store byte
  setINDF0( _data );
  // Start transmitting
  TXIE = TRUE;
}

//############################################################################################
// W = read byte, Carry = result
bit RxUART()
//############################################################################################
{
  // Buffer empty?
  if ( RxDataLengthUART == 0 )
    return FALSE;

  // Disable RX interrupt
  RCIE = FALSE;
  // Get byte from the circular buffer
  FSR0 = RxBufferUART + RxBufferPointerStartUART;
  // Optimization: RxBufferPointerStartUART = ( RxBufferPointerStartUART + 1 ) % UART_BUFFER_LENGTH;
  RxBufferPointerStartUART++;
  RxBufferPointerStartUART &= ~UART_BUFFER_LENGTH;
  // One byte less
  RxDataLengthUART--;
  // Returned byte
  W = *FSR0;
  // Enable RX interrupt
  RCIE = TRUE;
  // TRUE => byte was read
  return TRUE;
}

//############################################################################################
void CalibrateParam3()
//############################################################################################
{
  // Read calibration
  eeReadData( TEMP_CALIBRATION_ADDRESS, sizeof( uns16 ) );
  uns16 calib @ bufferINFO[0];
  param3 += calib;
}

//############################################################################################
// Default Custom DPA Handler header; 2nd include to implement Code bumper to detect too long code of the Custom DPA Handler (modify the path according to your setup)
#include "include/DPAcustomHandler.h"
//############################################################################################